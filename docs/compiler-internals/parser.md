# Parser

The parser, or syntactic analyzer, is the second stage of the NEURO compiler. It takes the flat stream of tokens generated by the lexer and transforms it into a hierarchical structure known as an Abstract Syntax Tree (AST).

- **Implementation**: `src/neuro/parser.py`
- **Main Class**: `NeuroParser`
- **AST Node Definitions**: `src/neuro/ast_nodes.py`

## The Abstract Syntax Tree (AST)

The AST is a tree representation of the source code's grammatical structure. Each node in the tree represents a construct in the code, like a variable declaration, a function call, or a binary operation.

For example, the code `let y = x + 10;` would be parsed into a tree structure that looks something like this:

```
VariableDeclaration(name='y',
  value=BinaryOperation(
    left=Identifier(name='x'),
    operator='+',
    right=Literal(value=10)
  )
)
```

This tree structure is much easier for the later stages of the compiler (like the type checker and code generator) to work with than a simple list of tokens.

## How it Works

The `NeuroParser` class implements a **recursive descent parser**. This is a top-down parsing strategy where a set of mutually recursive procedures is used to process the input.

- The parser has a main method, `parse()`, which attempts to parse the entire token stream into a `Program` node (the root of the AST).
- The `Program` node consists of a list of statements or declarations. The parser calls other methods to parse each specific type of statement (e.g., `parse_variable_declaration()`, `parse_function_declaration()`, `parse_expression_statement()`).
- These methods, in turn, may call other methods to parse sub-components. For example, `parse_variable_declaration()` will need to parse an expression for the variable's initial value.
- The parser handles operator precedence (e.g., ensuring that `*` is evaluated before `+` in `2 + 3 * 4`) by implementing a Pratt parsing-style approach for expressions. This makes it easy to handle complex mathematical and logical expressions.

## Error Handling

When the parser encounters a sequence of tokens that does not match the expected grammar (a syntax error), it attempts to recover and continue parsing.

- If it expects a semicolon but finds something else, it will report an error indicating a missing semicolon.
- It uses a synchronization mechanism to discard tokens until it finds one that seems to be the start of a new, valid statement (like a keyword). This prevents the parser from generating a cascade of confusing errors after the first mistake.
- All errors are reported via the `ErrorReporter`, providing precise location information from the tokens. 